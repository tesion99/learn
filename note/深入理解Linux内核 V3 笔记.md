# 深入理解Linux内核 V3 笔记

### 操作系统基本概念

**内核(kernel)** ---- 任何计算机系统都包含一个名为操作系统的基本程序集合。在这个集合里，最重要的程序称为**内核**

操作系统必须完成的两个主要目标:

- 与硬件部分交互，为包含在硬件平台上的所有低层可编程部件提供服务
- 为运行在计算机系统上的应用程序(即用户程序)提供运行环境



CPU两种执行模式

- **用户态(User Mode)** ---- 用户程序的非特权模式
- **内核态(Kernel Mode)** ---- 内核的特权模式



**进程(process)** ---- 程序执行时的一个实例或者一个运行程序的执行上下文

**地址空间(address space)** ---- 允许进程引用的内存地址集合

**微内核(microkernel)**操作系统只需要内核有一个很小的函数集、，通常包括几个同步原语、一个简单的调度程序和进程间通信机制。



**文件系统**

- **硬链接与软链接**

  - 硬链接(hard link)是包含在目录中的文件名

    - 硬链接的限制

      - 不允许给目录创建硬链接。因为可能把目录树变为环形，从而就不可能通过名字定位一个文件
      - 只有在同一文件系统中的文件之间才能创建硬链接

      ```shell
      # 创建P1的硬链接P2
      ln P1 P2
      ```

      

  - 软链接(soft link)，也成符号链接(symbolic link)

    - 符号链接是短文件，其包含有另一个文件的任意一个路径名。路径名可以指向位于任意一个文件系统的任意文件或目录，甚至一个不存在的文件。

      ```shell
      # 创建P1的软链接P2
      ln -s P1 P2
      ```

- **文件类型**

  - 普通文件(regular file)
  - 目录
  - 符号链接
  - 面向块的设备文件
  - 面向字符的设备文件
  - 管道(pipe)与命名管道(named pipe)
  - 套接字(socket)

- 文件描述符与索引节点

  UNIX对*文件内容*和*描述文件的信息*给出了清楚的区分

  文件系统处理文件需要的所有信息包含在一个名为**索引节点(inode)**的数据结构中。文件系统用索引节点来标识文件

- **访问权限和文件模式**

  3种访问权限: 可读、可写、可执行

  3种附加标记: 

  - **suid**: 进程执行一个文件时通常保持**进程拥有者**的UID，如果设置了可执行文件的suid标志位，进程就获得**该文件拥有者**的UID
  - **sgid**: 同上类似，进程获得该文件用户组的ID
  - **sticky**: 设置了sticky标志位的可执行文件相当于向内核发出一个请求，当程序执行结束以后，依然将它保留在内存(**注: 该标志已过时**)



**内核概述**

1. 实际上，一些CPU可以有两种以上的执行状态；但是所有标准的UNIX内核都仅仅利用了**内核态**和**用户态**

2. 当一个程序在用户态下执行时，它不能直接访问内核数据结构或内核的程序；当应用程序在内核态下运行时，这些限制不再有效

   每种CPU模型都为从用户态到内核态的转换提供了特殊指令

- **进程/内核模式**

  UNIX系统除用户进程外，还包括几个所谓内核线程(kernel thread)的特权进程，其具有如下特点：

  - 它们以内核态运行在内核地址空间
  - 它们不与用户直接交互
  - 它们通常在系统启动时创建，然后一直处于活跃状态直到系统关闭

- 进程实现

  每个进程由一个进程描述符(process descriptor)表示；当内核暂停一个进程的执行时，就把几个相关处理器寄存器的内容保存在进程描述符中，这些寄存器包括:

  - 程序计数器(PC)和栈指针(SP)寄存器

    程序计数器中所存的值指向下一条将要执行的指令

  - 通用寄存器

  - 浮点寄存器

  - 包含CPU状态信息的处理器控制寄存器

  - 用来跟踪进程对RAM访问的内存管理寄存器

  **内核控制路径(kernel control path)**表示内核处理系统调用、异常或中断所执行的指令序列

- 进程地址空间

  每个进程运行在它的私有地址空间

  在用户态下运行的进程涉及到私有栈、数据区和代码区

  当在内核态运行时，进程访问内核的数据区和代码区，但使用另外的私有栈

- 同步和临界区

  **临界区(critical region)**是这样的一段代码，进入这段代码的进程必须完成，之后另一个进程才能进入

- 信号和进程间通信

  2种系统事件:

  - 异步通告
  - 同步错误或异常

  Unix System V引入了在用户态下其他种类的进程间通信机制：信号量、消息队列及共享内存，统称System V IPC

  IPC资源是**持久不变的**，进程必须**显式**地释放这些资源

- 进程管理

  - fork() 

    创建新进程；fork()的一种实现方式是将父进程的数据与代码都复制，并把这个拷贝赋予子进程。为节省消耗，内核采用写时复制(Copy-On-Write)技术

  - _exit()

    终止一个进程；内核对该系统调用的处理是通过释放进程所拥有的资源并向父进程发送**SIGCHILD**信号来实现

  - exec()类函数

    装入一个新程序，新程序在所装入程序的全新地址空间恢复运行

    

- 僵尸进程(zombie process)

- 进程组

  Unix操作系统引入进程组(process group)的概念，以表示一种"作业(job)"

  每个进程描述符包括一个包含进程组ID的字段

  每一进程组可以有一个领头进程(即PID与该进程组ID相同)

  新创建的进程最初被插入到其父进程的进程组中

**内存管理**

- 虚拟内存

  虚拟内存(virtual memory)作为一种逻辑层，处于应用程序的内存请求与硬件内存管理单元(Memory Management Unit, MMU)之间，其用途和优点有：

  - 应用程序所需内存大于可用物理内存时也可以运行
  - 允许每个进程访问可用物理内存的子集
  - 进程可以共享库函数或程序的一个单独内存映像

  虚拟内存子系统的主要成分是虚拟地址空间(virtual address space)的概念

  现在的CPU包含了能自动把虚拟地址转换成物理地址的硬件电路

- 随机访问存储器(RAM)

  所有的Unix操作系统都将RAM划分为2部分

  1. 其中若干兆字节专门用于存放内核映像(也就是内核代码和内核静态数据结构)
  2. 其余部分通常由虚拟内存系统来处理

  虚拟内存系统必须解决的一个主要问题是**内存碎片**

- 内核内存分配器

  内核内存分配器(Kernel Memory Allocator, KMA)是一个子系统，它试图满足系统中所有部分对内存的请求，基于不同的算法技术，KMA有不同的实现，包括:

  - 资源图分配算法(allocator)
  - 2的幂次方空闲链表
  - McKusick-Karels分配算法
  - 伙伴(Buddy)系统
  - Mach的区域(Zone)分配算法
  - Dynix分配算法
  - Solaris的Slab分配算法

  Linux的KMA在伙伴系统之上采用了Slab分配算法

- 进程虚拟地址空间

  进程虚拟地址空间包括了进程可以引用的所有虚拟内存地址

  虚拟地址空间由一下内存区组成

  - 程序的可执行代码
  - 程序的初始化数据
  - 程序的未初始化数据
  - 初始程序栈(即用户态栈)
  - 所需共享库的可执行代码和数据
  - 堆(由程序动态请求的内存)

  所有现代Unix操作系统都采用了所谓请求调页(demand paging)的内存分配策略。有了请求调页，进程可以在它的页还没有内存时就开始执行。当进程访问一个不存在的页时，MMU产生一个异常(缺页异常)；异常处理程序找到受影响的内存区，分配一个空闲的页，并用适当的数据把它初始化。同理，当进程通过调用malloc()或brk()系统调用动态请求内存时，内核仅仅修改进程的堆内存区大小。只有试图引用进程的虚拟内存地址而产生异常时，才给进程分配页帧(page frame)

**设备驱动程序**

设备文件(/dev/目录下)是设备驱动程序接口中用户可见的部分。每个设备文件都有专门的设备驱动程序，它们由内核调用以执行对硬件设备的请求操作



### 内存寻址

3种不同的地址：

1. 逻辑地址(logical address)

   包含在机器语言指令中用来指定一个操作数或一条指令的地址。每一个逻辑地址都由一个段(segment)和偏移量(offset)组成，偏移量指明了从段开始的地方到实际地址之间的距离

2. 线性地址(linear address)，也称虚拟地址(virtual address)

   一个32位无符号整数，可用来表示高达4GB的地址

   线性地址通常用十六进制数字表示，值范围从0x00000000到0xffffffff

3. 物理地址(physical address)

   用于内存芯片级内存单元寻址。它们与从微处理器的地址引脚发送到内存总线上的电信号相对应

   物理地址有32位或36位无符号整数表示

内存控制单元(MMU)通过一种称为分段单元(segmentation unit)的硬件电路把一个逻辑地址转换成线性地址；接着，第二个称为分页单元(paging unit)的硬件电路把线性地址转换成一个物理地址

**硬件中的分段**

- 段选择器和段寄存器

  一个逻辑地址由两部分组成：一个段标识符和一个指定段内相对地址的偏移量

  段标识符是一个16位长的字段，称为**段选择符(Segment Selector)**，偏移量是一个32位长的字段

  处理器提供**段寄存器**，其唯一目的是存放段选择符。这些段寄存器称为cs, ss, ds, es, fs和gs

  | 段寄存器        | 用途说明                       |
  | --------------- | ------------------------------ |
  | cs 代码段寄存器 | 指向包含程序指令的段           |
  | ss 栈段寄存器   | 指向包含当前程序栈的段         |
  | ds 数据段寄存器 | 指向包含静态数据或者全局数据段 |

  其他3个段寄存器作一般用途，可以指向任意的数据段

  cs寄存器还含有一个两位的字段，用以指明CPU的当前特权级别(Current Privilege Level, CPL)。值为0代表最高优先级，值为3代表最低优先级。

  **Linux只用0级和3级，分别称为内核态和用户态** 

- 段描述符



